/*
 * IOTgame.c
 *
 * Created: 14-10-2022 18:33:16
 * Author : amina
 */ 
#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>

#define DC 0
#define RST 1
#define SS 4
#define MOSI 5
#define SCK 7

//#define SPE 6
//#define MSTR 4
//#define CPOL 3

int box_num[2]={1,1};
const unsigned char canvas_data[]={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xff, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xff, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char cross_data[]={0x00, 0x02, 0x02, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x20, 0x20, 0x40, 0xc0, 0x80, 0x40, 0x20, 0x20, 0x10, 0x10, 0x10, 0x08, 0x08, 0x04, 0x02, 0x02,0x00, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10};

const unsigned char round_data[]={0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x08, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x08, 0x30, 0xe0, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x18, 0x08, 0x04, 0x06, 0x01, 0x00

};

const unsigned char cursor_data[]={0xBc, 0xA4, 0xBc};
	
int valid_box[9] = {0,0,0,0,0,0,0,0,0};



void uart_init(){
	UCSRA |= (1<<U2X);
	UCSRB |= (1<<TXEN) | (1<<RXEN);
	UCSRC |= (1<<UCSZ1) | (1<<UCSZ0) | (1<<URSEL);
	UBRRH = 0x00;
	UBRRL = 12;
}

void uart_transmit(unsigned char outgoing_data){
	while (!(UCSRA & (1<<UDRE)));
	UDR = outgoing_data;
}

char uart_recive(){
while (!(UCSRA & (1<<RXC)));
//unsigned char incoming_data = UDR;
//turn incoming_data;
PORTD ^= 80;
return UDR;
}

char data_recieve(){
	while (1){
		if( (PINC & (1 << PINC4)) == (1 << PINC4)){
			continue;
		}
		else
		return (PINC & 0x0F);
		break;
	}
}


void SPI_Init(void)
{
	/* Set MOSI and SCK output, all others input */
	DDRB |= (1<<MOSI)|(1<<SCK);
	/* Enable SPI, Master, set clock rate and clock polarity fck/4 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<CPOL);
}


void SPI_Transmit(char cData)
{
	/* Start transmission */
	SPDR = cData;
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)))
	;
	SPSR &= ~(1<<SPIF);
}


void disp_command(char byte){
	PORTB &= ~(1<<SS);
	PORTB &= ~(1<<DC);
	SPI_Transmit(byte);
	PORTB |= (1<<SS);
}


void disp_data(char data){
	PORTB &= ~(1<<SS);
	PORTB |= (1<<DC);
	SPI_Transmit(data);
	PORTB &= ~(1<<DC);
	PORTB |= (1<<SS);
}


void disp_init(){
	DDRB |= (1<<DC)|(1<<RST)|(1<<SS);
	PORTB |= (1<<RST)|(1<<SS);
	PORTB &=~(1<<DC);
	_delay_us(1);
	PORTB &= ~(1<<SS);
	PORTB &= ~(1<<RST);
	_delay_ms(100);
	PORTB |= (1<<RST);
	PORTB |= (1<<SS);
	SPI_Init();
	
	disp_command(0x21);   //use extended instruction
	disp_command(0xC0);   //Vop
	disp_command(0x07);   //Set temp coefficient
	disp_command(0x14);   //Bias System
	disp_command(0x20);   //Normal instruction mode
	disp_command(0x0C);	  // DIsplay configuration
	return;
}


void clear(){
	for (int i=0; i<=503; i++){
		disp_data(0x00);
	}

}


void draw_X(int box){
	int k=0;
	switch(box)
	{
		case 1:
		disp_command(0x80);
		disp_command(0x40);
		for(int i=0; i<=49; i++){
			if(i==25){
				disp_command(0x80);
				disp_command(0x41);
				k = 59;
			}
			disp_data((canvas_data[i+k] | cross_data[i]));
		}
		break;

		case 2:
		disp_command(0x9c);
		disp_command(0x40);
		for(int i=28; i<=77; i++){
			if(i==53){
				disp_command(0x9c);
				disp_command(0x41);
				k = 59;
			}
			disp_data((canvas_data[i+k] | cross_data[i-28]));
		}
		break;

		case 3:
		disp_command(0xBA);
		disp_command(0x40);
		for(int i=58; i<=107; i++){
			if(i==83){
				disp_command(0xBA);
				disp_command(0x41);
				k = 59;
			}
			disp_data((canvas_data[i+k] | cross_data[i-58]));
		}
		break;

		case 4:
		disp_command(0x80);
		disp_command(0x42);
		for(int i=0; i<=49; i++){
			if(i==25){
				disp_command(0x80);
				disp_command(0x43);
			}
			disp_data( cross_data[i]);
		}
		break;

		case 5:
		disp_command(0x9c);
		disp_command(0x42);
		for(int i=0; i<=49; i++){
			if(i==25){
				disp_command(0x9c);
				disp_command(0x43);
			}
			disp_data( cross_data[i]);
		}
		break;

		case 6:
		disp_command(0xBA);
		disp_command(0x42);
		for(int i=0; i<=49; i++){
			if(i==25){
				disp_command(0xBA);
				disp_command(0x43);
			}
			disp_data( cross_data[i]);
		}
		break;

		case 7:
		disp_command(0x80);
		disp_command(0x44);
		for(int i=336; i<=385; i++){
			if(i==361){
				disp_command(0x80);
				disp_command(0x45);
				k = 59;
			}
			disp_data((canvas_data[i+k] | cross_data[i-336]));
		}
		break;

		case 8:
		disp_command(0x9C);
		disp_command(0x44);
		for(int i=364; i<=413; i++){
			if(i==389){
				disp_command(0x9C);
				disp_command(0x45);
				k = 59;
			}
			disp_data((canvas_data[i+k] | cross_data[i-364]));
		}
		break;
		
		case 9:
		disp_command(0xBA);
		disp_command(0x44);
		for(int i=392; i<=441; i++){
			if(i==417){
				disp_command(0xBA);
				disp_command(0x45);
				k = 59;
			}
			disp_data((canvas_data[i+k] | cross_data[i-392]));
		}
		break;
	}

}


void draw_O(int box){
	int k=0;
	switch(box)
	{
		case 1:
		disp_command(0x80);
		disp_command(0x40);
		for(int i=0; i<=43; i++){
			if(i==22){
				disp_command(0x80);
				disp_command(0x41);
				k = 62;
			}
			disp_data((canvas_data[i+k] | round_data[i]));
		}
		break;

		case 2:
		disp_command(0x9c);
		disp_command(0x40);
		for(int i=28; i<=71; i++){
			if(i==50){
				disp_command(0x9c);
				disp_command(0x41);
				k = 62;
			}
			disp_data((canvas_data[i+k] | round_data[i-28]));
		}
		break;

		case 3:
		disp_command(0xBA);
		disp_command(0x40);
		for(int i=58; i<=101; i++){
			if(i==80){
				disp_command(0xBA);
				disp_command(0x41);
				k = 62;
			}
			disp_data((canvas_data[i+k] | round_data[i-58]));
		}
		break;

		case 4:
		disp_command(0x80);
		disp_command(0x42);
		for(int i=0; i<=43; i++){
			if(i==22){
				disp_command(0x80);
				disp_command(0x43);
			}
			disp_data( round_data[i]);
		}
		break;

		case 5:
		disp_command(0x9c);
		disp_command(0x42);
		for(int i=0; i<=43; i++){
			if(i==22){
				disp_command(0x9c);
				disp_command(0x43);
			}
			disp_data( round_data[i]);
		}
		break;

		case 6:
		disp_command(0xBA);
		disp_command(0x42);
		for(int i=0; i<=43; i++){
			if(i==22){
				disp_command(0xBA);
				disp_command(0x43);
			}
			disp_data( round_data[i]);
		}
		break;

		case 7:
		disp_command(0x80);
		disp_command(0x44);
		for(int i=336; i<=379; i++){
			if(i==358){
				disp_command(0x80);
				disp_command(0x45);
				k = 62;
			}
			disp_data((canvas_data[i+k] | round_data[i-336]));
		}
		break;

		case 8:
		disp_command(0x9C);
		disp_command(0x44);
		for(int i=364; i<=407; i++){
			if(i==386){
				disp_command(0x9C);
				disp_command(0x45);
				k = 62;
			}
			disp_data((canvas_data[i+k] | round_data[i-364]));
		}
		break;
		
		case 9:
		disp_command(0xBA);
		disp_command(0x44);
		for(int i=392; i<=435; i++){
			if(i==414){
				disp_command(0xBA);
				disp_command(0x45);
				k = 62;
			}
			disp_data((canvas_data[i+k] | round_data[i-392]));
		}
		break;
	}

}


void cursor(int num){
	int l;
	switch(num){
		case 1:
		disp_command(0x8A);
		disp_command(0x40);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 2:
		disp_command(0xA8);
		disp_command(0x40);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 3:
		disp_command(0xc6);
		disp_command(0x40);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 4:
		disp_command(0x8A);
		disp_command(0x43);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 5:
		disp_command(0xA8);
		disp_command(0x43);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 6:
		disp_command(0xC6);
		disp_command(0x43);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 7:
		disp_command(0x8A);
		disp_command(0x45);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 8:
		disp_command(0xA8);
		disp_command(0x45);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
		case 9:
		disp_command(0xC6);
		disp_command(0x45);
		for(l=0;l<=2;l++){
			disp_data(cursor_data[l]);
		}
		break;
	}
}


void clear_cursor(int num){
	int l;
	switch(num){
		case 1:
		disp_command(0x8A);
		disp_command(0x40);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 2:
		disp_command(0xA8);
		disp_command(0x40);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 3:
		disp_command(0xc6);
		disp_command(0x40);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 4:
		disp_command(0x8A);
		disp_command(0x43);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 5:
		disp_command(0xA8);
		disp_command(0x43);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 6:
		disp_command(0xC6);
		disp_command(0x43);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 7:
		disp_command(0x8A);
		disp_command(0x45);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 8:
		disp_command(0xA8);
		disp_command(0x45);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
		case 9:
		disp_command(0xC6);
		disp_command(0x45);
		for(l=0;l<=2;l++){
			disp_data(0x00);
		}
		break;
	}
}

void disp_graphic(){
	PORTB &= ~(1<<SS);
	PORTB |= (1<<DC);
	for (int k=0; k<=503; k++)
	{
		SPI_Transmit(canvas_data[k]);
	}
	PORTB &= ~(1<<DC);
	PORTB |= (1<<SS);
}

int main(void)
{
	DDRA = 0x00;
    disp_init();
	clear();
	disp_graphic();
	cursor(box_num[1]);
	//while(1){
		//if(PINA == 0x02){
		 //DDRD = 0x80;
		 //PORTD ^= 0x80;
		 //_delay_ms(1000); 
		//}
	//}
	while(1){	
	if(PINA == 0x02){
		box_num[1]++;
		if(box_num[1] == 9)
			box_num[1] = 1;
		clear_cursor(box_num[0]);
		while (valid_box[box_num[1]-1] != 0){
			box_num[1]++;
			if(box_num[1] == 9)
				box_num[1] = 1;
		}
		cursor(box_num[1]);
		box_num[0] = box_num[1];
		_delay_ms(1000);
	}
	
	if(PINA == 0x01){
		draw_X(box_num[1]);
		//uart_transmit(box_num[1]);
		valid_box[box_num[1]-1]=1;
		//player = 2;
		_delay_ms(700);
	}	
	}
}